class BuyInPortugal
types
	public Category = seq of char;
	public SubCategory = seq of char;
	public AdminCode = seq of char;

instance variables
	public categories : set of Category := {};
	public subcategories : map SubCategory to Category := { |-> };
	public manufacturers : map Manufacturer`Name to Manufacturer := { |-> };
	public clients : map Client`Email to Client := { |-> };
	
	public adminCode : AdminCode := [];

operations
	public BuyInPortugal: () ==> BuyInPortugal
	BuyInPortugal() ==
		return self;
	
	-- Change admin password
	public setAdminCode: AdminCode * AdminCode ==> ()
	setAdminCode(curCode, nextCode) ==
		adminCode := nextCode
	pre curCode = adminCode;
	
	-- Register manufacturer
	public registerManufacturer: Manufacturer`Name * AdminCode ==> Manufacturer
	registerManufacturer(name, code) == (
		dcl m:Manufacturer := new Manufacturer(name);
		addManufacturer(m);
		return m;
	)
	pre name not in set dom manufacturers
		and code = adminCode
	post dom manufacturers = dom manufacturers~ union {name};

	private addManufacturer: Manufacturer ==> ()
	addManufacturer(m) == (
	manufacturers := manufacturers munion { m.name |-> m };
	);
	
	-- Register client
	public registerClient: Client`Email ==> Client
	registerClient(email) == (
	dcl c:Client := new Client(email);
		addClient(c);
		return c;
	)
	pre email not in set dom clients
	post dom clients = dom clients~ union {email};

	private addClient: Client ==> ()
	addClient(c) == (
	clients := clients munion { c.email |-> c };
	);

end BuyInPortugal