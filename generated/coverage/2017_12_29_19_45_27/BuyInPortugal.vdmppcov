class BuyInPortugal
types
	public Category = seq of char;
	public Subcategory = seq of char;
	public AdminCode = seq of char;

instance variables
	public categories : set of Category := {};
	public subcategories : map Subcategory to Category := { |-> };
	public manufacturers : map Manufacturer`Name to Manufacturer := { |-> };
	public products : map Product`Title to Product := { |-> };
	public clients : map Client`Email to Client := { |-> };
	
	public adminCode : AdminCode := [];
	
	-- subcategories should be associated with category
  inv rng subcategories subset categories;

operations
	/** ADMIN OPERATIONS **/
	public BuyInPortugal: () ==> BuyInPortugal
	BuyInPortugal() ==
		return self;
	
	-- Change admin password
	public setAdminCode: AdminCode * AdminCode ==> ()
	setAdminCode(curCode, nextCode) ==
		adminCode := nextCode
	pre curCode <> nextCode
		and curCode = adminCode;
	
	-- Register manufacturer
	public registerManufacturer: Manufacturer`Name * AdminCode ==> Manufacturer
	registerManufacturer(name, code) == (
		dcl m:Manufacturer := new Manufacturer(name);
		addManufacturer(m);
		return m;
	)
	pre name not in set dom manufacturers
		and code = adminCode
	post dom manufacturers = dom manufacturers~ union {name};

	private addManufacturer: Manufacturer ==> ()
	addManufacturer(m) == (
		manufacturers := manufacturers munion { m.name |-> m };
	);
	
	-- Add category
	public addCategory: Category * AdminCode ==> set of Category
	addCategory(category, code) == (
		categories := categories union {category};
		return categories;
	)
	pre category not in set categories
		and code = adminCode
	post categories = categories~ union {category};
	
	-- Set categories
	public setCategory: set of Category * AdminCode ==> set of Category
	setCategory(cats, code) == (
		categories := cats;
		return categories;
	)
	pre code = adminCode;
	
	-- Add subCategories
	public addSubcategory: Subcategory * Category * AdminCode ==> map Subcategory to Category
	addSubcategory(subcategory, category, code) == (
		subcategories := subcategories munion {subcategory |-> category};
		return subcategories;
	)
	pre subcategory not in set dom subcategories
		and category in set categories
		and code = adminCode
	post dom subcategories = dom subcategories~ union {subcategory};
	
	-- Set subCategories
	public setSubcategory: map Subcategory to Category * AdminCode ==> map Subcategory to Category
	setSubcategory(subcats, code) == (
		subcategories := subcats;
		return subcategories;
	)
	pre code = adminCode;
	/** ADMIN OPERATIONS END **/
	
	
	/** MANUFACTURER OPERATIONS **/
	
	-- Add product
	public addProduct: Manufacturer`Name *  Product`Title * Product`Description * Product`Subcategory * Product`Price * map Product`Color to Product`Quantity * set of Product`Color ==> ()
	addProduct(manName, tit, des, cat, pr, qties, cors) == (
		dcl product : Product := new Product(tit, des, cat, pr, qties, cors);
		--let manufacturer = manufacturers(manName),
			--product;
			return;
	)
	pre manName in set dom manufacturers
		and tit not in set dom products
	post dom products = dom products~ union {tit};
	/** MANUFACTURER OPERATIONS END **/


	/** CLIENT OPERATIONS **/
	/** CLIENT OPERATIONS END **/
	
	
	/** VISITOR OPERATIONS **/
	-- Register client
	public registerClient: Client`Email ==> Client
	registerClient(email) == (
	dcl c:Client := new Client(email);
		addClient(c);
		return c;
	)
	pre email not in set dom clients
	post dom clients = dom clients~ union {email};

	private addClient: Client ==> ()
	addClient(c) == (
		clients := clients munion { c.email |-> c };
	);
	/** VISITOR OPERATIONS END **/
	

end BuyInPortugal